@file:Suppress("unused")

package land.sungbin.kotlindumper

import java.io.File
import java.util.concurrent.ArrayBlockingQueue
import java.util.concurrent.Callable
import java.util.concurrent.CopyOnWriteArrayList
import java.util.concurrent.ForkJoinPool
import java.util.concurrent.ForkJoinTask
import java.util.concurrent.Future
import java.util.concurrent.RecursiveTask
import java.util.concurrent.ThreadFactory
import java.util.concurrent.ThreadPoolExecutor
import java.util.concurrent.TimeUnit
import java.util.concurrent.TimeoutException
import java.util.concurrent.atomic.AtomicInteger
import kotlin.math.max
import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
import org.jetbrains.kotlin.cli.common.messages.MessageCollector

data class WorkStealingConfig(
  val parallelism: Int,
  val asyncMode: Boolean = false,
  val workerTimeout: Long = 10L,
) {
  companion object {
    fun autoConfig(): WorkStealingConfig {
      val p = Runtime.getRuntime().availableProcessors()
      return WorkStealingConfig(parallelism = p, asyncMode = false, workerTimeout = 10L)
    }

    fun minimalConfig(): WorkStealingConfig {
      val p = Runtime.getRuntime().availableProcessors()
      return WorkStealingConfig(parallelism = max(2, p / 2), asyncMode = false, workerTimeout = 10L)
    }
  }
}

// 통계
data class WorkStealingStatistics(
  val poolSize: Int,
  val activeThreads: Int,
  val queuedTasks: Long,
  val completedWorkers: Long,
  val failedWorkers: Long,
  val stealCount: Long,
  val isQuiescent: Boolean,
)

// Generated by ChatGPT 5 !!!!!
// 코디네이터
class WorkStealingDumpCoordinator(
  private val messageCollector: MessageCollector,
  private val config: WorkStealingConfig = WorkStealingConfig.autoConfig(),
) {
  // 계산용 ForkJoinPool
  private val fjp = ForkJoinPool(
    config.parallelism,
    ForkJoinPool.defaultForkJoinWorkerThreadFactory,
    null,
    config.asyncMode,
  )

  // 파일 I/O 풀
  private val ioId = AtomicInteger()
  private val ioPool = ThreadPoolExecutor(
    max(2, Runtime.getRuntime().availableProcessors() / 2),
    max(2, Runtime.getRuntime().availableProcessors() / 2),
    30L, TimeUnit.SECONDS,
    ArrayBlockingQueue(4096),
    ThreadFactory { r -> Thread(r, "io-${ioId.incrementAndGet()}").apply { isDaemon = true } },
    ThreadPoolExecutor.CallerRunsPolicy()
  )

  // 상태
  private val submitted = CopyOnWriteArrayList<ForkJoinTask<List<Future<*>>>>()
  private val completed = AtomicInteger()
  private val failed = AtomicInteger()

  // 내부 태스크: 문자열 계산
  class ComputeStringTask(
    private val name: String,
    private val supplier: () -> String,
  ) : RecursiveTask<Pair<String, String>>() {
    public override fun compute(): Pair<String, String> {
      if (Thread.interrupted()) throw InterruptedException("cancelled before compute")
      val content = supplier()
      return name to content
    }
  }

  // 파일 쓰기
  private fun writeToFile(file: File, content: String) {
    if (Thread.interrupted()) throw InterruptedException("cancelled before write")
    file.parentFile?.mkdirs()
    file.bufferedWriter().use { it.write(content) }
  }

  /** IR 전용 제출: FIR은 전혀 평가하지 않음 */
  fun submitIrOnly(
    dstPath: () -> File,
    irString: () -> String,
    irKtString: () -> String,
  ): ForkJoinTask<List<Future<*>>> {
    val task = fjp.submit(object : RecursiveTask<List<Future<*>>>() {
      override fun compute(): List<Future<*>> {
        val dst = dstPath().also { it.mkdirs() }
        val tIr = ComputeStringTask("ir.txt", irString)
        val tIrKt = ComputeStringTask("ir.kt.txt", irKtString)

        tIr.fork()
        val rIrKt = tIrKt.compute()
        val rIr = tIr.join()

        return listOf(rIr, rIrKt).map { (name, content) ->
          ioPool.submit(Callable { writeToFile(File(dst, name), content) })
        }
      }
    })
    submitted.add(task)
    return task
  }

  /** FIR 전용 제출: IR은 전혀 평가하지 않음 */
  fun submitFirOnly(
    dstPath: () -> File,
    firString: () -> String,
  ): ForkJoinTask<List<Future<*>>> {
    val task = fjp.submit(object : RecursiveTask<List<Future<*>>>() {
      override fun compute(): List<Future<*>> {
        val dst = dstPath().also { it.mkdirs() }
        val rFir = ComputeStringTask("fir.txt", firString).compute()
        val f = ioPool.submit(Callable { writeToFile(File(dst, rFir.first), rFir.second) })
        return listOf(f)
      }
    })
    submitted.add(task)
    return task
  }

  /** FIR + IR 동시 제출 */
  fun submitFirAndIr(
    dstPath: () -> File,
    firString: () -> String,
    irString: () -> String,
    irKtString: () -> String,
  ): ForkJoinTask<List<Future<*>>> {
    val task = fjp.submit(object : RecursiveTask<List<Future<*>>>() {
      override fun compute(): List<Future<*>> {
        val dst = dstPath().also { it.mkdirs() }
        val tFir = ComputeStringTask("fir.txt", firString)
        val tIr = ComputeStringTask("ir.txt", irString)
        val tIrKt = ComputeStringTask("ir.kt.txt", irKtString)

        tIr.fork()
        tIrKt.fork()
        val rFir = tFir.compute()
        val rIr = tIr.join()
        val rIrKt = tIrKt.join()

        return listOf(rFir, rIr, rIrKt).map { (name, content) ->
          ioPool.submit(Callable { writeToFile(File(dst, name), content) })
        }
      }
    })
    submitted.add(task)
    return task
  }

  /** 전체 완료 대기. 워커별 타임아웃은 config.workerTimeout 초 */
  fun awaitCompletion(timeoutMinutes: Long = 60) {
    val deadline = System.nanoTime() + TimeUnit.MINUTES.toNanos(timeoutMinutes)
    for (task in submitted) {
      val remain = deadline - System.nanoTime()
      if (remain <= 0) {
        task.cancel(true); failed.incrementAndGet(); continue
      }

      val ioFutures: List<Future<*>> = try {
        task.get(config.workerTimeout, TimeUnit.SECONDS)
      } catch (_: TimeoutException) {
        task.cancel(true); failed.incrementAndGet(); continue
      } catch (_: InterruptedException) {
        task.cancel(true); failed.incrementAndGet(); Thread.currentThread().interrupt(); continue
      } catch (e: Exception) {
        messageCollector.report(CompilerMessageSeverity.WARNING, e.message?.plus(" ") + e.cause)
        failed.incrementAndGet(); continue
      }

      var ok = true
      for (f in ioFutures) {
        val remain2 = deadline - System.nanoTime()
        if (remain2 <= 0) {
          f.cancel(true); ok = false; break
        }
        try {
          f.get(minOf(remain2, TimeUnit.SECONDS.toNanos(config.workerTimeout)), TimeUnit.NANOSECONDS)
        } catch (_: TimeoutException) {
          f.cancel(true); ok = false; break
        } catch (_: InterruptedException) {
          f.cancel(true); Thread.currentThread().interrupt(); ok = false; break
        } catch (e: Exception) {
          messageCollector.report(CompilerMessageSeverity.WARNING, e.message?.plus(" ") + e.cause)
          ok = false; break
        }
      }
      if (ok) completed.incrementAndGet() else failed.incrementAndGet()
    }
  }

  fun shutdown() {
    fjp.shutdown()
    ioPool.shutdown()
    try {
      fjp.awaitTermination(5, TimeUnit.MINUTES)
      ioPool.awaitTermination(2, TimeUnit.MINUTES)
    } catch (_: InterruptedException) {
      fjp.shutdownNow()
      ioPool.shutdownNow()
      Thread.currentThread().interrupt()
    }
  }

  fun getStatistics(): WorkStealingStatistics = WorkStealingStatistics(
    poolSize = fjp.poolSize,
    activeThreads = fjp.activeThreadCount,
    queuedTasks = fjp.queuedTaskCount,
    completedWorkers = completed.get().toLong(),
    failedWorkers = failed.get().toLong(),
    stealCount = fjp.stealCount,
    isQuiescent = fjp.isQuiescent,
  )
}